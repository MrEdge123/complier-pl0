# complier-pl0

编译原理：pl0实验与课设

## 实验

### 实验要求

1. 增加单词：关键字：`for`，`to`，`downto`； 符号: `+=`，`-=`，`++`，`--`。 要求: 词法识别即可
2. 替换单词：不等号`#`改为`<>`
3. 增加条件语句的`else`子句

### 实验内容

#### 1.增加若干个单词（只需语法识别）

单词的定义位置：`pl0.h`中的`enum symbol`

```c
enum symbol
{
    nul,
    ident,
    number,
    plus,
    minus,
    ...,
}
```

涉及到的变量：

`pl0.h`中：

> `symnum`：单词数量，取决于`symbol`中有多少个单词
> 
> `norw`：关键字数量，取决于`symbol`中有多少个关键字（保留字）

要求中，需要新增7个单词和3个关键字，所以：

```
symnum += 7;
norw += 3
```

`pl0.c`，`init()`函数中：

> `word`：关键字的字符串数组，`word[i]`代表第`i`个关键字的字符串形式。顺序是按照从小到大的[字典序](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F) ，作用：二分查找关键字
> 
> `wsym`：关键字数组。`wsym[i]`代表第`i`个关键字，与`word[i]`是一一对应的

在修改时，要注意：

1. `word`要按照从小到大的字典序
2. `wsym[i]`和`word[i]`必须一一对应，即相同的下标，含义是同样的单词

最重要的地方，**词法识别**：`getsym()`函数

对于新关键字，是在`搜索当前符号是否为保留字`这个位置进行识别的。只要我们修改了`word`和`wsym`变量，这里就可以识别到关键字。

对于新符号，是在`按照单字符符号处理`这个**位置前**进行识别的，原因是：我们添加的新符号，第一个字符，即`+`，`-`，修改前是在这个位置处理的。

#### 2.替换单词（不等号`#`改为`<>`）

这部分比较简单，只需要在`init()`函数的`ssym`去掉对`#`的识别，在`getsym()`增加对`<>`的识别即可。详细看commit记录。

#### 3.增加条件语句的`else`子句

首先，按照上述增加单词的方法，增加关键字`else`

接下来，要对`else`进行语义分析：

`else`子句的文法：`if <条件> then <语句> else <语句>`

从文法中可知：`else`子句应该在识别了`if then`语句代码的后面。所以开始寻找`if then`语法识别的代码位置。

通过搜索`thensym`，发现在`statement()`函数中的`thensym`位置才是需要修改的。

从当前位置，先分析之前的`if then`语句是怎样进行语法识别的：

代码解释：

> `nextlev`：后跟单词数组，在处理`<条件>`前，需要设置`<条件>`的后跟单词
>
> `conditiondo()`：处理`<条件>`函数`condition()`的宏定义
>
> `cx`，`cx1`：`cx`为最新指令的末尾位置；`cx1`则是记录指令位置的临时变量
>
> `gendo()`：生成指令函数`gen()`的宏定义。每生成一条指令，`cx`就会加`1`
>
> `statementdo()`：处理`<语句>`函数`statement()`的宏定义
> 
> `code`：指令数组，存放生成的指令

流程图：

![](png/1.png)

如果要进一步理解代码，必须知道pl0**代码**和pl0**指令**的对应关系，接下来介绍pl0指令集：

pl0虚拟机的组成：`interpret()`函数

> `s`：存储栈，这里用数组进行实现
> 
> `t`：栈顶指针，即栈顶的位置
> 
> `i`：当前的指令
> 
> `p`：指令地址，即指令的位置
> 
> `b`：指令基址，关于层次功能的实现需要用到

整个解释程序，就是**从上到下按顺序**（除了一些跳转指令）执行指令，中间数据用**栈**来存储。

虚拟机指令格式：

```
F L A
```

含义：

> `F`：指令的类型
> 
> `L`：在某些指令中，表示层次差。如果没用到则为0
> 
> `A`：不同指令含义不同

详细指令在书`P15`页，这里只介绍关键的指令：

> `opr 0 a`，`a ∈ [8,13]`：二元比较指令。如果满足条件，则将`1`存入次栈顶；否则，将`0`存入次栈顶；最后栈顶指针`t`减`1`
> 
> `jpc 0 a`：条件跳转指令。如果栈顶为`0`，则当前的指令指针，跳转到指令地址`a`；否则什么都不做，继续执行下一条指令
> 
> `jmp 0 a`：直接跳转指令。当前的指令指针，直接跳转到指令地址`a`

有了上述知识后，我们可以尝试得出`if then`语句和指令的对应关系：

```
1| if <条件> then  // opr 0 a; jpc 0 i; 即不满足条件就跳转到第8行的位置
2| begin
3|     <语句1>;    // ...
4|     <语句2>;    // ...
*|     ...  
7| end;
8| <语句>          // 由第i个指令开始 (i不一定等于8, 要看扫描到这里时的cx变量值)
```

注意到，在生成`jpc`指令的时候，因为是从上到下识别的，这时还不知道**跳转的指令地址**。所以，只能当知道指令地址的时候，再**回填**指令地址，`jpc`指令才算完整

**回填**在代码中的体现：

> 用`cx1`这个临时变量，记录`jpc`指令的位置。处理完`<语句>`后，根据`cx1`找回之前的指令。最后把最新的指令地址`cx`，填入到之前指令的`A`地址部分

这时，我们应该明白流程图的这两个步骤了：

![](png/2.png)

接下来考虑`if then else`语句和指令的对应关系：

```
01| if <条件> then    // opr 0 a; jpc 0 i; 即不满足条件就跳转到第11行的位置
02|     begin
03|         <语句1>;  // ...
04|         <语句2>;  // ...
**|         ...
08|     end          // jmp 0 j; 直接跳转到17行的位置
09| else
10|     begin
11|         <语句1>;  // 由第i个指令开始
12|         <语句2>;
**|         ...
16|     end;
17| <语句>            // 由第j个指令开始
```

上面用`begin end`语句是为了具体化，更加方便理解，现在抽象成一般情况：

```
1| if <条件> then  // opr 0 a; jpc 0 i;
2|     <语句>
3|                // 回填jpc指令, i = cx + 1
4| else           // jmp 0 j;
5|     <语句>;     // 由第i个指令开始
6|                // 回填jmp指令, j = cx
7| <语句>          // 由第j个指令开始
```

小细节：`i = cx + 1`是为了跳过`jmp`指令

最后，要注意修改完后，原来的`if then`语句也能正常工作。

`else`子句的流程图：

![](png/3.png)
